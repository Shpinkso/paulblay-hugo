<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Metrics on Paul Blay</title><link>https://paulblay.com/categories/metrics/</link><description>Recent content in Metrics on Paul Blay</description><generator>Hugo</generator><language>en-gb</language><lastBuildDate>Mon, 20 Jul 2020 11:46:20 +0100</lastBuildDate><atom:link href="https://paulblay.com/categories/metrics/index.xml" rel="self" type="application/rss+xml"/><item><title>Complexity as a Software metric</title><link>https://paulblay.com/blog/2020/07/20/complexity_as_sw_metric/</link><pubDate>Mon, 20 Jul 2020 11:46:20 +0100</pubDate><guid>https://paulblay.com/blog/2020/07/20/complexity_as_sw_metric/</guid><description>&lt;p&gt;I’ve never been completely sold on Cyclomatic Complexity as a metric, it maps to linearly independent paths through code which may be useful to get an indication on the level of testing an application needs, assuming code coverage is not available (another metric that needs to be treated with caution), but how much value is that? Most applications are multi threaded and do not run in a linear fashion, I’d argue that there’s considerably more value in measuring the readability of code in order to allow people to understand what it does and how to change it. I’ve seen easy-to-read and hard-to-read methods that evaluate to the same value on the Cyclomatic Complexity scale. Perhaps that’s ok and we care about logical complexity, but my (weakly held) strong opinion is that the real value is in ease of human understanding when it comes to code.&lt;/p&gt;</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CI on Paul Blay</title><link>https://shpinkso.github.io/paulblay-hugo/previews/main/tags/ci/</link><description>Recent content in CI on Paul Blay</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 15 Oct 2025 11:37:12 +0100</lastBuildDate><atom:link href="https://shpinkso.github.io/paulblay-hugo/previews/main/tags/ci/index.xml" rel="self" type="application/rss+xml"/><item><title>Painful Vibe coding with Codex</title><link>https://shpinkso.github.io/paulblay-hugo/previews/main/blog/2025/10/15/trying_out_codex/</link><pubDate>Wed, 15 Oct 2025 11:37:12 +0100</pubDate><guid>https://shpinkso.github.io/paulblay-hugo/previews/main/blog/2025/10/15/trying_out_codex/</guid><description>Use of LLMs I&amp;rsquo;ve been using LLMs for a while, primarily as a buddy that can help me with ideation or noticing gaps in my thinking.
I rarely use the LLM output directly because it never feels complete or authentic. For written word, I find it can generate pretty generic wording with little impact or personality.
Anything I do take directly, I&amp;rsquo;ll rework pretty heavily - and it&amp;rsquo;s just a judgement of whether doing the rework is more efficient than just starting from scratch.</description></item><item><title>Complexity as a Software metric</title><link>https://shpinkso.github.io/paulblay-hugo/previews/main/blog/2020/07/20/complexity_as_sw_metric/</link><pubDate>Mon, 20 Jul 2020 11:46:20 +0100</pubDate><guid>https://shpinkso.github.io/paulblay-hugo/previews/main/blog/2020/07/20/complexity_as_sw_metric/</guid><description>I’ve never been completely sold on Cyclomatic Complexity as a metric, it maps to linearly independent paths through code which may be useful to get an indication on the level of testing an application needs, assuming code coverage is not available (another metric that needs to be treated with caution), but how much value is that? Most applications are multi threaded and do not run in a linear fashion, I’d argue that there’s considerably more value in measuring the readability of code in order to allow people to understand what it does and how to change it.</description></item></channel></rss>